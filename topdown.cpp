/*
  Justin Weiss, Cole Burkhart, Jacky Shi
  3/29/19
  CSC4510
  BC Version 3 - Recursive Decent Parser
*/


#include "general_ex.h"
#include<iostream>
#include<stdio.h>
#include<ctype.h>
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include "symbolTable.h"

extern Symbol_table table;
extern Symbol_ptr symbol_ptr;
Symbol_ptr symbol_ptr2;

using namespace std;


/*stmt
Parses strings inthe langauge generated by the rule:
<stmt> -> ID = <expr>
       | QUIT
       | DUMP
*/
int stmt()
{
   int value = 0;

   lex();



   //Case ID = expr
   if(nextToken == EQUAL){

      lex();
      //gets the value
      value = expr();
      //loads into symbol table
      symbol_ptr->putval(value);

      //Prints the value
      cout << "        " << symbol_ptr->getid() << "=" << value << endl;
      symbol_ptr = NULL;

   }

   //if the nextoken is dump then dump the table
   if(nextToken == DUMP){
      cout << "Dump" << endl;
      cout << "================" << endl;
      table.dump_table();
      cout << "================" << endl;
   }

   //if the next token is quit then quit the table
   if(nextToken == QUIT){
      nextToken = EOF;
      exit(1);
   }


    return value;

}
/* expr
 Parses strings in the language generated by the rule:
 <expr> -> <term> {(+ | -) <term>}
 */
int expr()
{
    int value1 = 0;
    int value2 = 0;

 /* Parse the first factor */
     value1 = term();
    /* As long as the next token is + or -, get the
     next token and parse the next factor */
     while (nextToken == ADD_OP || nextToken == SUB_OP) {
       if(nextToken == ADD_OP){
          lex();
          value2 = term();
          value1 = value1 + value2;
       }else if(nextToken == SUB_OP){
          lex();
          value2 = term();
          value1 = value1 - value2;
      }
      lex();
     }
     return value1;


} /* End of function expr */
/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
int term()
{
    int value1 = 0;
    int value2 = 0;

 /* Parse the first factor */
     value1 = negatives();
     //lex();

    /* As long as the next token is * or / or %, get the
     next token and parse the next factor */
     while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD) {
        if(nextToken == MULT_OP){
          lex();
          value2 = factor();
          value1 = value1 * value2;
       }else if(nextToken == DIV_OP){
          lex();
          value2 = factor();
          value1 = value1 / value2;
      }
      else if(nextToken == MOD){
         lex();
         value2 = factor();
         value1 = value1 % value2;
      }
      lex();
     }

     return value1;

} /* End of function term */
/* factor
 * Parses strings in the language generated by the rule:
 *
 * <factor> -> id | int_constant | ( <expr )
 *
 */
int factor()
{

    //If it is a number
    //return it
    if(nextToken == INT_LIT){
      // cout << "out of factor" << endl;
       return atoi(lexeme);
    }

    //if is ident
    else if (nextToken == IDENT){
       /* Get the next token */

        //if there is a value
        int result;
        result = symbol_ptr->getval();
        //then return
        return result;
    }

    /* If the RHS is ( <expr> ), call lex to pass over the left
    parenthesis, call expr and check for the right parenthesis */
    else if (nextToken == LEFT_PAREN) {
       lex();
       int value = expr();
       if (nextToken == RIGHT_PAREN){
          return value;
          }

       else
          error("Right without left paren");
    }
    else {
    /* It was not an id, an integer literal, or a left
    parenthesis */
    error("expected an id, integer, or a left paren");
    return 0;
    } /* End of else */


}/* End of function factor */

//Checks for unary minus
//if there is one then mult the value by -1
int negatives()
{
  int value = 0;

 //will return a negative number
 if(nextToken == SUB_OP){
    lex();
    value = powers();
    value *= -1;
 }
 else{
    value = powers();
 }

  return value;

}
//Calculate exponments
//returns the power
int powers()
{
//will return a number that has been raised to a power

   int value1 = factor();
   lex();

   //gets the exponents
   while(nextToken == EXPO){
      lex();
      int value2 = factor();
      value1 = pow(value1, value2);

      lex();

   }

   return value1;

}


void error(const char *message)
{
 printf("Error: %s\n",message);
}
